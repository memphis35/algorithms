package com.company.linkedlist.homework;

import com.company.exceptions.EmptyListException;
import com.company.linkedlist.linklist.Link;

/**
 * @homework 5.3. Циклическим списком называется связанный список, в котором последний
 * элемент содержит ссылку на первый элемент. Существует много способов реализа-
 * ции циклических списков. Иногда объект списка содержит указатель на «начало»
 * списка. Однако в этом случае список уже не похож на замкнутый круг, а больше
 * напоминает обычный список, у которого конец связан с началом. Создайте класс
 * для односвязного списка, не имеющий ни начала, ни конца. Доступ к списку осу-
 * ществляется по единственной ссылке current, которая может указывать на любой
 * элемент списка. Ссылка перемещается по списку так, как требуется пользователю
 * (ситуация, для которой идеально подходит циклический список, представлена
 * в проекте 5.5). Список должен поддерживать операции вставки, поиска и удаления.
 * Вероятно, удобнее выполнять эти операции с элементом, следующим за тем, на
 * который указывает current. (Так как список является односвязным, вы не сможе-
 * те вернуться к предыдущему элементу без полного прохождения всей цепочки.)
 * Также следует предусмотреть возможность вывода содержимого списка (хотя его
 * придется разбить в некоторой точке для вывода на экран). Метод step(), который
 * перемещает current к следующему элементу, тоже может пригодиться.
 */
public class LoopedLinkList {

    private Link current;

    public void setCurrent(Link current) {
        this.current = current;
    }

    Link getCurrent() {
        return current;
    }

    public void insert(String data) {
        Link element = new Link(data);
        if (isEmpty()) {
            element.setNext(element);
            current = element;
        } else {
            element.setNext(current.getNext());
            current.setNext(element);
        }
    }

    private void next() {
        if (current.getNext() != null) {
            current = current.getNext();
        }
    }

    public Link delete() throws EmptyListException {
        Link result = current.getNext();
        if (isOnlyOne()) {
            current.setNext(current.getNext().getNext());
        } else {
            current = null;
        }
        result.setNext(null);
        return result;
    }

    private boolean isEmpty() {
        return current == null;
    }

    public void clear() {
        while (current != null) {
            delete();
        }
    }

    private boolean isOnlyOne() {
        return !current.equals(current.getNext());
    }

    /**
     * @homework 5.5 Задача Иосифа Флавия — известная математическая задача с историческим
     * подтекстом. Существует много легенд о том, как она возникла. В одной из них
     * говорится, что Иосиф был в составе гарнизона осажденной крепости, которую
     * должны были захватить римляне. Защитники крепости предпочли смерть рабству.
     * Они выстроились в круг, и начинали считать по кругу, выбрав в качестве начала
     * отсчета конкретного человека. Каждый n-й по счету покидал круг и совершал само-
     * убийство. Иосиф решил, что ему умирать еще рано, и выбрал такие правила, чтобы
     * остаться последним из выживших. Если в круге было (например) 20 человек и он
     * был седьмым от начала отсчета, какое число следовало выбрать для отсчета? Задача
     * сильно усложняется тем, что круг уменьшается по мере выбывания участников.
     * Создайте приложение, моделирующее задачу с использованием циклического
     * связанного списка (как в проекте 5.3). Во входных параметрах передаются коли-
     * чество людей в круге, число для отсчета и номер человека, с которого начинается
     * отсчет (чаще всего 1). Программа выводит список выбывающих. Когда один из
     * участников выходит из круга, отсчет начинается заново слева от него (предпо-
     * лагается, что отсчет ведется по часовой стрелке). Например, если в круге стоят
     * семеро участников с номерами от 1 до 7, а отсчет ведется через 3 позиции (начиная
     * с позиции 1), то участники выбывают в порядке 4, 1, 6, 5, 7, 3. Номер 2 остается
     * последним.
     */

    private void fill(int quantity) {
        int i = 1;
        Link temp = new Link("man #" + i);
        current = temp;
        while (i++ < quantity) {
            temp.setNext(new Link("man #" + i));
            temp = temp.getNext();
        }
        temp.setNext(current);
        current = temp;
    }

    private void whereIsJoseph(int mans, int even) {
        fill(mans);
        while (isOnlyOne()) {
            int i = even;
            while (i-- > 1) {
                next();
            }
            System.out.println("Deleting " + delete().getData());
        }
        System.out.println("Joseph is a " + current.getData());
    }
}
